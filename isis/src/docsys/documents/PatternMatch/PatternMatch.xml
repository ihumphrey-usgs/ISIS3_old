<?xml version="1.0" encoding="UTF-8" ?>

<documentation xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:noNamespaceSchemaLocation=
  "http://isis.astrogeology.usgs.gov/Schemas/Documentation/documentation.xsd">

  <files>
    <file>
      <body>

        <h3>Table of Contents</h3>
        <ol type="I">
          <li><a href="#Introduction">Introduction</a></li>
          <ol type="i">
            <li><a href="#PluginsAndPvl">Plugins and PVL</a></li>
          </ol>

          <li><a href="#Chips">Chips</a></li>
          <ol type="i">
            <li><a href="#PatternChip">Pattern Chip</a></li>
            <li><a href="#SearchChip">Search Chip</a></li>
            <li><a href="#Restrictions">Restrictions</a></li>
          </ol>

          <li><a href="#MatchAlgorithms">Match Algorithms</a></li>
          <ol type="i">
            <li><a href="#MinimumDifference">Minimum Difference</a></li>
            <li><a href="#MaximumCorrelation">Maximum Correlation</a></li>
            <li><a href="#Tolerance">Tolerance</a></li>
          </ol>

          <li><a href="#CreatingFitChip">Creating a Fit Chip</a></li>
          <ol type="i">
            <li><a href="#DenseWalk">Dense Walk</a></li>
            <li><a href="#SparseWalk">Sparse Walk</a></li>
          </ol>

          <li><a href="#SubPixelAccuracy">Sub-Pixel Accuracy</a></li>
          <ol type="i">
            <li><a href="#SurfaceModeling">Surface Modeling</a></li>
            <li>
              <a href="#FindingLocalMinMax">Finding a Local Minimum/Maximum</a>
            </li>
          </ol>

          <li><a href="#AdvancedFeatures">Advanced Features</a></li>
          <ol type="i">
            <li>
              <a href="#RestrictingPixelRanges">Restricting Pixel Ranges</a>
            </li>
            <li>
              <a href="#ValidPixelCount">Valid Pixel Count</a>
            </li>
            <li>
              <a href="#ReductionFactor">Reduction Factor</a>
            </li>
            <li>
              <a href="#GeoWarping">Geometric Warping of Pattern Cubes</a>
            </li>
            <li>
              <a href="#SamplingMatchAlgo">Sampling in the Match Algorithm</a>
            </li>
            <li><a href="#ZScoreTest">Z-Score Test</a></li>
            <li><a href="#GradientFilters">Gradient Filters</a></li>
          </ol>

          <li><a href="#Appendices">Appendices</a></li>
          <ol type="i">
            <li>
              <a href="#DeffileKeywords">Definition File Keywords</a>
            </li>
          </ol>
        </ol>

        <hr />

        <!-- Introduction -->
        <h2><a name="Introduction">Introduction</a></h2>
        <p>
          This document attempts to describe how automatic registration is
          accomplished in Isis 3.  In simple terms, automatic registration is
          the attempt to match a pattern in a cube.  For example, given a reseau
          template pattern, we would like to find positions in a cube which
          match the reseau.  Similarly, if we extract from a cube a ground
          feature (e.g. crater, fault line, etc) as a pattern, we would like to
          find the same feature in another overlapping cube to define match
          points.  
        </p>

        <h3><a name="PluginsAndPvl">Plugins and PVL</a></h3>
        <p>
          Automatic registration is a tricky subject.  Algorithms and
          parameters that successfully work for one pattern are likely not to
          work for other conditions.  In Isis 3, we do not want to restrict our
          registration programs (e.g., coreg, pointreg) to a single algorithm.
          We would view this similar to map projections or camera models.  That
          is, if a particular registration algorithm meets our needs we can
          choose to use it, however, if none meet our needs a new algorithm can
          be developed.  A key element is we want the new algorithm immediately
          available in all applications without the need to modify them.  We
          will facilitate this requirement through plugins and the use of
          Parameter Value Language (PVL) definition files.   The PVL syntax
          will be introduced gradually as the overall discussion of automatic
          registration progresses.
        </p>

        <!-- Chips -->
        <h2><a name="Chips">Chips</a></h2>
        <p>
          In the simplest terms, automatic registration attempts to find some
          sub-area of a cube (or "pattern") inside some subarea of another cube
          (or "search" window).  In ISIS, these "generally" small sub-areas of
          a cube are called "chips".  There are two chips used in automatic
          registration, the "pattern" chip and the "search" chip, corresponding
          to the two sub-areas discussed above.   We will discuss each in more
          detail within the following sections, but for now we describe the
          basic elements of a chip.  That is, an NxM chip is defined to be an N
          sample by M line region of a cube.  Some key elements of a chip are
          as follows:

          <ol>
            <li>N and M are natural numbers (1, 2, 3, ...)</li>
            <li>Like cubes, chip coordinates are sample/line based and indexed from 1</li>
            <li>The center of the chip is (N-1)/2 + 1 and (M-1)/2 + 1.</li>
          </ol>

          Because a chip is a region of a cube, there must be a technique to
          "load" the chip.  The most common method for accomplishing this is to
          specify a cube coordinate (a sample and line) to be loaded as the
          center pixel of the chip.
        </p>

        <h3><a name="PatternChip">Pattern Chip</a></h3>
        <p>
          The pattern chip contains the data you want to match.  In the past we
          have called this the "truth" chip or "hold" chip.  Both of these
          terms can be confusing.  The term "truth" has different meanings in
          regards to match points and term "hold" is misleading as a pattern
          chip actually floats through the search chip. So we refrain from
          their use and stick with the term "pattern" chip.   The PVL for a
          pattern chip is:

          <pre style="padding-left:4em;">
            Object = AutoRegistration
              Group = PatternChip
                Samples = 5
                Lines   = 5
              End_Group
            End_Object
          </pre>
        </p>

        <h3><a name="SearchChip">Search Chip</a></h3>
        <p>
          The search chip is the area of an overlapping cube you believe the
          pattern will fall within (TODO how is this specified).  That is, we
          will walk the pattern chip through the search chip looking for the
          best match.  The size of the search chip defines how far the pattern
          chip is allowed to deviate from a desired center search spot.
          Consequently, the search chip must be larger than the pattern chip in
          order for the pattern chip to move through the search chip:  

          <pre style="padding-left:4em;">
            Object = AutoRegistration
              Group = PatternChip
                Samples = 5
                Lines   = 5
              End_Group

              Group = SearchChip
                Samples = 21
                Lines   = 21
              End_Group
            End_Object
          </pre>
        </p>

        <h3><a name="Restrictions">Restrictions</a></h3>
        <p>
          From the above discussion of pattern and search chips, an intuition
          should be developing about how changes to one chip will necessitate
          changes to the other.  Because the pattern chip and search chip are
          tightly coupled in this way, there are some restrictions on the
          relative dimensions of the two chips that must be put in place.
          Specifically:

          <ol>
            <li>
              <strong>N + M >= 3</strong>
              <br />
              where N and M are the dimensions of the pattern chip.  This
              ensures the pattern is not a single pixel.  However, in practice,
              small pattern chips often match too many areas in a search chip.
            </li>
            <li>
              <strong>
                N<sub>search</sub> >= N<sub>pattern</sub>+2
              </strong>
              and
              <strong>
                M<sub>search</sub> >= M<sub>pattern</sub>+2
              </strong>
              <br />
              where N and M are again the dimensions of their respective chips.
              This ensures that the pattern chip spans at least a 3x3 window in
              the search chip.  This is a subtle but important requirement for
              surface fitting in order to compute sub-pixel accuracy (which
              will be discussed later in this document).
            </li>
          </ol>
        </p>

        <!-- Match Algorithms -->
        <h2><a name="MatchAlgorithms">Match Algorithms</a></h2>
        <p>
          Rarely in practice will the pixels in a search chip have a one-to-one
          correspondance with some sub-area of the search chip.  Consequently,
          we introduce match algorithms designed to correlate two chips and
          find the "best" match within the search area.
        </p>
        <p>
          An objective of the Isis 3 automatic registration design is to allow
          for a variety of match algorithms.  For example, an algorithm could
          be developed that works best for matching MGS/MOC wide angle and
          Odyssey Themis IR cameras.  For this objective to be met we will
          utilize applications which allow automatic registration plugins.
          This concept is identical to that of applications which utilize
          camera and/or map projection plugins such as cam2map, map2map, etc. 
        </p>
        <p>
          The plugin match algorithm will receive the pattern chip and a
          sub-region of the search chip.  This sub-region will have the same
          dimensions as the pattern chip to allow for a pixel-by-pixel
          comparison of the chips.  The algorithm is expected to return a
          single value that represents the "goodness of fit" (GOF) between the
          two chips.   The definition of the GOF is algorithm dependent.  For
          clarity, we present two types of match algorithms in this document
          with the understanding that more algorithms may be developed in the
          future.
        </p>

        <h3><a name="MinimumDifference">Minimum Difference</a></h3>
        <p>
          This match algorithm defines goodness-of-fit as the average absolute
          difference per pixel between the pattern chip and the search
          sub-region.  Specifically, it sums the pixel differences within the
          pattern chip and search sub-region and divides by the total pixel
          count to get an average.  In equation form:

          <pre style="padding-left:4em;">
            GOF =  <span style="font-size:2.0em;">&#931;</span>|pattern(i,j) - subregion(i,j)| / count
          </pre>

          A GOF value of zero indicates a perfect match, while larger values
          indicate a less likely match.  Obviously, negative values could never
          occur.
        </p>
        <p>
          To have your automatic registration use this Minimum Difference
          algorithm, specify the following in the "Algorithm" group of your PVL
          definition file:

          <pre style="padding-left:4em;">
            Object = AutoRegistration
              Group = PatternChip
                Samples = 5
                Lines   = 5
              End_Group

              Group = SearchChip
                Samples = 21
                Lines   = 21
              End_Group

              Group = Algorithm 
                Name    = MinimumDifference
              End_Group
            End_Object
          </pre>
        </p>

        <h3><a name="MaximumCorrelation">Maximum Correlation</a></h3>
        <p>
          This match algorithm computes the correlation coefficient, R, between
          the pattern chip and the sub-region of the search chip as follows:

          <pre style="padding-left:4em;">
            R = Covariance(pattern, subregon) / [Variance(pattern) * Variance(subregion)]

            where -1.0 &lt;= R &lt;= 1.0

            GOF = |R|
          </pre>

          In this algorithm, the goodness of fit will range from no correlation
          (zero) to perfect correlation (one).  Example PVL for this algorithm
          would as follows:

          <pre style="padding-left:4em;">
            Object = AutoRegistration
              Group = PatternChip
                Samples = 5
                Lines   = 5
              End_Group

              Group = SearchChip
                Samples = 21
                Lines   = 21
              End_Group

              Group = Algorithm 
                Name    = MaximumCorrelation
              End_Group
            End_Object
          </pre>
        </p>

        <h3><a name="Tolerance">Tolerance</a></h3>
        <p>
          In both algorithms we will want to define a tolerance for goodness of
          fit.   The tolerance test must be made by the plugin as the direction
          of the test is dependent on the algorithm.  In our two examples
          MinimumDifference would use a test for "less than" Tolerance while the
          MaximumCorrelation would use "greater than" Tolerance.  This is
          represented in PVL in the following fashion:

          <pre style="padding-left:4em;">
            Object = AutoRegistration
              Group = PatternChip
                Samples = 5
                Lines   = 5
              End_Group

              Group = SearchChip
                Samples = 21
                Lines   = 21
              End_Group

              Group = Algorithm 
                Name      = MaximumCorrelation
                Tolerance = 0.7
              End_Group
            End_Object 
          </pre>

          In fact, the plugin will have significant control such that one, two,
          or more tolerances or test conditions must be satisfied to accept the
          match.  For example:

          <pre style="padding-left:4em;">
            Group = Algorithm 
              Name      = SuperSpecialRegistration
              Tolerance = 0.7
              ChiSquare = 2.5
              R         = 0.6
              T         = 95.0
            End_Group
          </pre>
        </p>

        <!-- Creating a Fit Chip -->
        <h2><a name="CreatingFitChip">Creating a Fit Chip</a></h2>
        <p>
          We define a third chip, the fit chip, which represents the goodness of
          fit at each equivalent position in the search chip.  That is, we can
          think of the pattern chip walking through the search chip and at each
          position extract a sub-region to be used for computing a fit
          value. After walking and computing at each position we have a chip
          filled with goodness of fit values that are in 1-1 correspondence with
          pixels in the search chip.  An example of the pattern chip weaving its
          way through the search chip is given:
        </p>
        <img src="assets/exampleWalk.jpg" alt="Example Walk" />
        <p>
          How the pattern chip walks the search chip can vary; currently we
          define two methods, a dense and sparse walk. 
        </p>

        <h3><a name="DenseWalk">Dense Walk</a></h3>
        <p>
          In the obvious case, we walk every possible position in the search
          chip by starting in the upper-left corner and moving over by one
          sample.  When we come to the right edge we will move down one line and
          reset to the left edge.  However, we do not test where the pattern
          would lie outside the search chip.  For example:
        </p>
        <img src="assets/denseWalk.jpg" alt="Dense Walk" />
        <p>
          In other words, we only test the pattern if it is fully inside of the
          search chip.  This will be true for all walking scenarios.  Therefore,
          if we have 3x3 pattern chip and a 7x7 search chip, we compute fits for
          25 of the 49 pixels in the search chip.
        </p>

        <h3><a name="SparseWalk">Sparse Walk</a></h3>
        <p>
          A sparse walk uses a sample and line increment to move the pattern
          chip.  The resultant fit chip will have a sparse sampling of
          data.  The walking algorithm will search for the best goodness of fit
          value in the sparse fit chip and then compute densely around that
          point.  The advantage is that sparse walking will reduce the number of
          computations, especially for large chips.  This is facilitated through
          PVL as:

          <pre style="padding-left:4em;">
            Group = SearchChip
              Samples     = 21
              Lines       = 21
              Density     = (2,3)
            End_Group
          </pre>

          In this case, every other sample and every third line will be tested
          in the search chip.  If density is not specified it defaults to (1,1)
          which is a dense walk.  It is important to recognize there is a risk
          using the sparse walk.  The algorithm can miss the best fit and
          compute an incorrect pixel match.  So there is a speed versus accuracy
          tradeoff.
        </p>

        <!-- Sub-Pixel Accuracy -->
        <h2><a name="SubPixelAccuracy">Sub-Pixel Accuracy</a></h2>
        <p>
          Upon walking the pattern chip through the search chip we will have
          created the fit chip.  The highest (or lowest) goodness of fit value
          generally represents the position that best matched between the
          pattern and search area.  It is however only good to one pixel
          accuracy.
        </p>
        <p>
          In many cases, the actual registration may lie somewhere between two
          pixels. This is due to the fact that we are using a set of finite data
          to estimate something that is in fact continuous.
        </p>

        <h3><a name="SurfaceModeling">Surface Modeling</a></h3>
        <p>
          To get around this problem, we can model a continuous mathematical
          surface based on the data in the fit chip. By calculating a 2nd degree
          2-dimentional polynomial given an NxN window of points, we have a
          reasonable approximation under a given tolerance of the underlying
          structure. We can then estimate the true registration position of the
          chip on that surface.
        </p>
        <p>
          Optionally, the window size and tolerance may be supplied through PVL:

          <pre style="padding-left:4em;">
            Group = SurfaceModel
              DistanceTolerance = 2.5
              WindowSize        = 7
              EccentricityRatio = 50.0
              ResidualTolerance = 0.05
            End_Group
          </pre>

          The distance tolerance in pixels must be greater than 0 and is
          defaulted to 1.0. The window size must be an odd number greater than 2
          and is defaulted to 3.
        </p>
        <p>
          The eccentricity ratio and residual tolerance correspond to the
          optional eccentricity and average residual tests.  By default, neither
          test is performed during surface model construction.  However, if the
          SurfaceModel PVL group contains one of both of those keywords, it will
          enable the respective test(s) with the given tolerance(s).  
        </p>

        <h3><a name="FindingLocalMinMax">Finding a Local Minimum/Maximum</a></h3>
        <p>
          After a surface is modeled over the data, we can use a number of
          techniques to calculate the local extreme. For example, when using the
          MinimumDifference algorithm the registration occurs at the minimal
          value on the surface. The result should fall within one pixel of the
          best calculated fit.
        </p>
        <p>
          It is important to note that while the surface modeling option is on
          by default it is possible to turn it off by using the SubpixelAccuracy
          keyword. Example:

          <pre style="padding-left:4em;">
            Group = Algorithm 
              Name             = MaximumCorrelation
              Tolerance        = 0.7
              SubpixelAccuracy = False
            End_Group
          </pre>

          In this case, the whole pixel with the best fit is returned.
        </p>
        <p>
          Also, if an ideal goodness of fit is found (e.g. 0.0 for
          MinimumDifference or 1.0 for MaximumCorrelation), we have a perfect
          fit and, thus, know it is in the best position. In this case, the
          sub-pixel accuracy phase is omitted.
        </p>

        <!-- Advanced Features -->
        <h2><a name="AdvancedFeatures">Advanced Features</a></h2>
        <p>
          This section covers advanced features of automatic
          registration.  While these features are not necessary in order to
          accomplish the registration, they can be used to significantly improve
          the chance of success and/or the accuracy of the match.
        </p>

        <h3><a name="RestrictingPixelRanges">Restricting Pixel Ranges</a></h3>
        <p>
          Pixels may be excluded from the match algorithm if they fall outside
          of a specified range.  This range is independent for both the pattern
          and search chip.  It is handled via the PVL as follows:

          <pre style="padding-left:4em;">
            Object = AutoRegistration
              Group = PatternChip
                Samples      = 5
                Lines        = 5
                ValidMinimum = 0.1
                ValidMaximum = 0.4
              End_Group

              Group = SearchChip
                Samples      = 21
                Lines        = 21
                ValidMinimum = 2.5
                ValidMaximum = 10.5
              End_Group

              ...
            End_Object
          </pre>

          If values are not given in the PVL then all pixels are considered
          valid (with the exception of special pixels).
        </p>

        <h3><a name="ValidPixelCount">Valid Pixel Count</a></h3>
        <p>
          Prior to the match algorithm being invoked during the walk process, a
          simple test is performed to ensure there are enough pixels to work
          with.  Pixels are deemed valid if they are in the minimum/maximum
          range and/or they are not special pixels.  The pattern chip is only
          checked once.  If it does not contain enough valid pixels the match is
          deemed to fail.  As the walk through occurs, the sub-region is
          extracted from the search chip. If this sub-region does not have
          enough valid pixels a match will be deemed to fail at that search
          location.  In the following PVL example we have a 5x5 chip with 25
          pixels of which 80% or more must be valid:

          <pre style="padding-left:4em;">
            Group = PatternChip
              Samples      = 5
              Lines        = 5
              ValidMinimum = 0.1
              ValidMaximum = 0.4
              ValidPercent = 80
            End_Group
          </pre>

          We only need to specify the percent for the pattern chip as the
          sub-region chip of the search area will use the same value. 
        </p>

        <h3><a name="ReductionFactor">Reduction Factor</a></h3>
        <p>
          The automatic registration process can often be a time-consuming one,
          especially when needing to consider a large search area to talk
          through.  In order to help speed up this portion of the process, we
          introduce the notion of a "Reduction Factor".
        </p>
        <p>
          If a reduction factor greater than 1 is specified by the user, then
          before attempting to walk the pattern chip through the search chip
          looking for a match, the algorithm will first perform a "reduced
          match".  In other words, new pattern and search chips will be created
          with dimensions equal to the original chip dimensions divided by the
          reduction factor.  For example, a common reduction factor is 1.5, and
          can be specified in the definition file as follows:

          <pre style="padding-left:4em;">
            Object = AutoRegistration
              Group = Algorithm
                ReductionFactor = 1.5
              End_Group

              Group = PatternChip
                Samples      = 5
                Lines        = 5
              End_Group

              Group = SearchChip
                Samples      = 21
                Lines        = 21
              End_Group
            End_Object
          </pre>

          In the above example, a new pattern chip will be constructed with
          dimensions of 3 samples by 3 lines (i.e., 5 / 1.5 rounded down).  The
          new search chip, likewise, will be 14 samples by 14 lines (i.e., 21 /
          1.5).
        </p>
        <p>
          Of course, by reducing the chips we lose an amount of detail directly
          proportionate to the magnitude of the reduction factor.  Increasing
          the reduction factor will speed up computation, but also decrease the
          reliability of the result.  A pixel in a reduced chip is simply
          computed by averaging surrounding pixels in the original chip.
        </p>
        <p>
          After the match has been performed on the reduced chips, instead of
          simply accepting the result, the algorithm will continue on to
          matching the original chips, but decrease the search area to some
          smaller area surrounding the "best" sample and line derived from the
          reduced match, effectively cropping the search chip (not scaling it,
          as in the reduced match) to some general area suspected to contain
          the exact match.  Increasing the reduction factor will increase the
          size of the resulting search area.
        </p>
        <p>
          Adaptive algorithms will make additional use the "best" sample and
          line dervied from the reduced match when setting up its affine
          transformations.
        </p>

        <h3><a name="GeoWarping">Geometric Warping of Pattern Cubes</a></h3>
        <p>
          The pattern cube can be forced to match the geometry of the search
          cube by using map projections and/or camera models.  Additionally,
          rotations can be applied to the pattern cube.  The warping is
          application dependent and therefore is under the control of the
          programmer.  That is, there is no PVL mechanism for warp
          selection/deselection.
        </p>

        <h3><a name="SamplingMatchAlgo">Sampling in the Match Algorithm</a></h3>
        <p>
          To increase the speed of the match algorithm data in the pattern chip
          and the sub-region of the search chip can be sampled.  While the
          sampling may cause the algorithm to run faster it may be at the
          expense of finding the best registration.  In PVL:

          <pre style="padding-left:4em;">
            Group = PatternChip
              Samples  = 10
              Lines    = 10
              Sampling = 50
            End_Group
          </pre>

          In the above example, half of the data would be compared in the
          matching algorithm. So, instead of looking at all 100 pixels, the
          algorithm will compare 50 evenly spaced values.  If the sampling
          keyword is not present then 100 is assumed and all data will be used.
        </p>

        <h3><a name="ZScoreTest">Z-Score Test</a></h3>
        <p>
          To guarantee an accurate match, we first need to check if the pattern
          chip has enough variation to perform the algorithm on. This is done by
          calculating the z-score of both the minimum and maximum values of the
          chip. The z-score measures the number of standard deviations the value
          is away from the mean. If the z-score for either value is greater than
          the specified minimum value, then it is an acceptable pattern
          chip. For example:

          <pre style="padding-left:4em;">
            Group = PatternChip 
              MinimumZScore = 1.5
            End_Group
          </pre>

          In this case, the chip's extreme values must be more than 1.5 standard
          deviations away from the mean. If the MinimumZScore keyword is not
          included, the default value of 1 standard deviation is used.
        </p>

        <h3><a name="GradientFilters">Gradient Filters</a></h3>
        <p>
          To increase the chances of successful registration, a gradient filter
          can be applied to both the search and pattern chips before attempting
          to perform a match. A gradient filter basically calculates the
          magnitude and direction of the largest possible increase from light to
          dark. In simple terms, a gradient filter highlights the edges in an
          image. Thus, the use of a gradient filter on the search and pattern
          chips may increase the chances of finding a match when the pattern
          chip contains distinctive features whose edges need to be emphasized.

          Currently, Sobel and Roberts gradient filters are supported. The Sobel
          gradient filter looks at the eight surrounding pixels for a given
          point, while the Roberts gradient filter computes the sum of the
          squares of the differences between diagonally adjacent pixels. A
          Sobel gradient filter can be specified like so:

          <pre style="padding-left:4em;">
            Group = Algorithm
              Gradient = Sobel
            End_Group
          </pre>
        </p>

        <!-- Appendices -->
        <h2><a name="Appendices">Appendices</a></h2>
        <p>
          Here you'll find a collection of quick references to help improve
          your results when performing automatic registration.
        </p>

        <h3><a name="DeffileKeywords">Definition File Keywords</a></h3>
        <p>
          The following table provides an exhaustive listing of every
          <strong>keyword</strong> that can be provided in an automatic
          registration definition file.  The keywords are organized by what
          <strong>groups</strong> they can appear in.  The
          <strong>type</strong> column specifies what kind of value is expected
          (an integer, real number, boolean, or a string).  The
          <strong>values</strong> column provides either the set of valid
          values (in the case of strings) or a numerical range, with a paren
          "(" denoting an exclusive value and a bracket "[" denoting an
          inclusive value.  The <strong>default</strong> column provides the
          value that will be taken when the keyword is not provided.  If the
          value for a particular cell is <span style="color:red;">red</span>,
          then instead of the corresponding keyword defaulting to some value in
          the registration process, the stated action will be performed.  In
          the case of an <span style="color:red;">Exception</span>, unless the
          specific application being used handles the missing value, the
          registration will fail.
        </p>

        <table class="tableFormattedInformation" align="center">
          <!-- Headers -->
          <tr>
            <th>Keyword</th>
            <th>Groups</th>
            <th>Type</th>
            <th>Values</th>
            <th>Default</th>
          </tr>

          <!-- Algorithm -->
          <tr>
            <td><a href="#MatchAlgorithms"><strong>Name</strong></a></td>
            <td>Algorithm</td>
            <td>String</td>
            <td>{MaximumCorrelation, MinimumDifference, Gruen, AdaptiveGruen}</td>
            <td><span style="color:red;">Exception</span></td>
          </tr>
          <tr>
            <td><a href="#Tolerance"><strong>Tolerance</strong></a></td>
            <td>Algorithm</td>
            <td>Real</td>
            <td>[0.0, infinity)</td>
            <td><span style="color:red;">Exception</span></td>
          </tr>
          <tr>
            <td><a href="#GeoWarping"><strong>ChipInterpolator</strong></a></td>
            <td>Algorithm</td>
            <td>String</td>
            <td>{NearestNeighborType, BiLinearType, CubicConvolutionType}</td>
            <td>CubicConvolutionType</td>
          </tr>
          <tr>
            <td><a href="#ReductionFactor"><strong>ReductionFactor</strong></a></td>
            <td>Algorithm</td>
            <td>Integer</td>
            <td>[1, infinity)</td>
            <td>1</td>
          </tr>
          <tr>
            <td><a href="#SubPixelAccuracy"><strong>SubPixelAccuracy</strong></a></td>
            <td>Algorithm</td>
            <td>Boolean</td>
            <td>{True, False}</td>
            <td>True</td>
          </tr>
          <tr>
            <td><a href="#GradientFilters"><strong>Gradient</strong></a></td>
            <td>Algorithm</td>
            <td>String</td>
            <td>{None, Roberts, Sobel}</td>
            <td>None</td>
          </tr>

          <!-- Pattern Chip -->
          <tr>
            <td><a href="#Chips"><strong>Samples</strong></a></td>
            <td>PatternChip, SearchChip</td>
            <td>Integer</td>
            <td>[1, infinity)</td>
            <td><span style="color:red;">Exception</span></td>
          </tr>
          <tr>
            <td><a href="#Chips"><strong>Lines</strong></a></td>
            <td>PatternChip, SearchChip</td>
            <td>Integer</td>
            <td>[1, infinity)</td>
            <td><span style="color:red;">Exception</span></td>
          </tr>
          <tr>
            <td><a href="#RestrictingPixelRanges"><strong>ValidMinimum</strong></a></td>
            <td>PatternChip, SearchChip</td>
            <td>Real</td>
            <td>(-infinity, infinity)</td>
            <td>Isis::ValidMinimum</td>
          </tr>
          <tr>
            <td><a href="#RestrictingPixelRanges"><strong>ValidMaximum</strong></a></td>
            <td>PatternChip, SearchChip</td>
            <td>Real</td>
            <td>(-infinity, infinity)</td>
            <td>Isis::ValidMaximum</td>
          </tr>
          <tr>
            <td><a href="#ZScoreTest"><strong>MinimumZScore</strong></a></td>
            <td>PatternChip</td>
            <td>Real</td>
            <td>(0.0, infinity)</td>
            <td>1.0</td>
          </tr>
          <tr>
            <td><a href="#ValidPixelCount"><strong>ValidPercent</strong></a></td>
            <td>PatternChip</td>
            <td>Real</td>
            <td>(0.0, 100.0]</td>
            <td>50.0</td>
          </tr>

          <!-- Search Chip -->
          <tr>
            <td><a href="#ValidPixelCount"><strong>SubchipValidPercent</strong></a></td>
            <td>SearchChip</td>
            <td>Real</td>
            <td>(0.0, 100.0]</td>
            <td>50.0</td>
          </tr>

          <!-- Surface Model -->
          <tr>
            <td><a href="#SurfaceModeling"><strong>DistanceTolerance</strong></a></td>
            <td>SurfaceModel</td>
            <td>Real</td>
            <td>(0.0, infinity)</td>
            <td>1.5</td>
          </tr>
          <tr>
            <td><a href="#SurfaceModeling"><strong>WindowSize</strong></a></td>
            <td>SurfaceModel</td>
            <td>Integer</td>
            <td>[3, infinity) odd</td>
            <td>5</td>
          </tr>
          <tr>
            <td><a href="#SurfaceModeling"><strong>EccentricityRatio</strong></a></td>
            <td>SurfaceModel</td>
            <td>Real</td>
            <td>[1.0, infinity]</td>
            <td><span style="color:red;">No Eccentricity Test</span></td>
          </tr>
          <tr>
            <td><a href="#SurfaceModeling"><strong>ResidualTolerance</strong></a></td>
            <td>SurfaceModel</td>
            <td>Real</td>
            <td>[0.0, infinity]</td>
            <td><span style="color:red;">No Residual Test</span></td>
          </tr>
        </table>

      </body>

      <type>HTML</type>
      <source>
        <filename>PatternMatch.html</filename>
      </source>
    </file>
  </files>

  <category>
    <categoryItem>guide</categoryItem>
  </category>

  <audience>
    <target>advanced</target>
  </audience>

  <bibliography>
    <title>Pattern Matching</title>
    <brief>
      A discussion of pattern matching techniques used in ISIS, designed to help
      users construct automatic registration templates.
    </brief>
    <description>
      This article describes the pattern matching techniques used for automatic
      registration in ISIS.  The information is designed to give users an idea
      of how they can alter their automatic registration templates to improve
      their results from applications such as "pointreg" and "coreg".  This
      should also give programmers a better understanding of how AutoReg works.
    </description>
    <author>Travis Addair</author>
    <date>2011-02-23</date>
  </bibliography>

  <history>
    <change name="Travis Addair" date="2011-02-23">
      Original version
    </change>
    <change name="Jai Rideout" date="2011-03-10">
      Added gradient filter section
    </change>
  </history>
</documentation>
