<?xml version="1.0" encoding="UTF-8" ?>

<documentation xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:noNamespaceSchemaLocation=
  "http://isis.astrogeology.usgs.gov/Schemas/Documentation/documentation.xsd">

  <files>
    <file>
      <body>

        <h3>Table of Contents</h3>
        <ol type="I">
          <li><a href="#Introduction">Introduction</a></li>
          <ol type="i">
            <li><a href="#PluginsAndPvl">Plugins and PVL</a></li>
          </ol>

          <li><a href="#Chips">Chips</a></li>
          <ol type="i">
            <li><a href="#PatternChip">Pattern Chip</a></li>
            <li><a href="#SearchChip">Search Chip</a></li>
            <li><a href="#Restrictions">Restrictions</a></li>
          </ol>

          <li><a href="#MatchAlgorithms">Match Algorithms</a></li>
          <ol type="i">
            <li><a href="#MaximumCorrelation">Maximum Correlation</a></li>
            <li><a href="#MinimumDifference">Minimum Difference</a></li>
            <li><a href="#Gruen">Gruen</a></li>
            <li><a href="#Tolerance">Tolerance</a></li>
          </ol>

          <li><a href="#CreatingFitChip">Creating a Fit Chip</a></li>
          <ol type="i">
            <li><a href="#DenseWalk">Dense Walk</a></li>
          </ol>

          <li><a href="#SubPixelAccuracy">Sub-Pixel Accuracy</a></li>
          <ol type="i">
            <li><a href="#SurfaceModeling">Surface Modeling</a></li>
            <li>
              <a href="#FindingLocalMinMax">Finding a Local Minimum/Maximum</a>
            </li>
            <li><a href="#DistanceTolerance">Distance Tolerance</a></li>
            <li><a href="#WindowSize">Window Size</a></li>
            <li><a href="#EccentricityRatio">Eccentricity Ratio</a></li>
            <li><a href="#ResidualTolerance">Residual Tolerance</a></li>
          </ol>

          <li><a href="#AdvancedFeatures">Advanced Features</a></li>
          <ol type="i">
            <li>
              <a href="#RestrictingPixelRanges">Restricting Pixel Ranges</a>
            </li>
            <li>
              <a href="#ValidPixelCount">Valid Pixel Count</a>
            </li>
            <li>
              <a href="#ReductionFactor">Reduction Factor</a>
            </li>
            <li>
              <a href="#GeoWarping">Geometric Warping of Pattern Cubes</a>
            </li>
            <li><a href="#ZScoreTest">Z-Score Test</a></li>
            <li><a href="#GradientFilters">Gradient Filters</a></li>
          </ol>

          <li><a href="#Appendices">Appendices</a></li>
          <ol type="i">
            <li>
              <a href="#DeffileKeywords">Definition File Keywords</a>
            </li>
          </ol>
        </ol>

        <hr />

        <!-- Introduction -->
        <h2><a name="Introduction">Introduction</a></h2>
        <p>
          This document attempts to describe how automatic registration is
          accomplished in Isis 3.  In simple terms, automatic registration is
          the attempt to match a pattern in a cube.  For example, given a reseau
          template pattern, we would like to find positions in a cube which
          match the reseau.  Similarly, if we extract from a cube a ground
          feature (e.g. crater, fault line, etc) as a pattern, we would like to
          find the same feature in another overlapping cube to define match
          points.  
        </p>

        <h3><a name="PluginsAndPvl">Plugins and PVL</a></h3>
        <p>
          Automatic registration is a tricky subject.  Algorithms and
          parameters that successfully work for one pattern are likely not to
          work for other conditions.  In Isis 3, we do not want to restrict our
          registration programs (e.g., coreg, pointreg) to a single algorithm.
          We would view this similar to map projections or camera models.  That
          is, if a particular registration algorithm meets our needs we can
          choose to use it, however, if none meet our needs a new algorithm can
          be developed.  A key element is we want the new algorithm immediately
          available in all applications without the need to modify them.  We
          will facilitate this requirement through plugins and the use of
          Parameter Value Language (PVL) definition files.   The PVL syntax
          will be introduced gradually as the overall discussion of automatic
          registration progresses.
        </p>

        <!-- Chips -->
        <h2><a name="Chips">Chips</a></h2>
        <p>
          In the simplest terms, automatic registration attempts to find some
          sub-area of a cube (or "pattern") inside some subarea of another cube
          (or "search" window).  In ISIS, these "generally" small sub-areas of
          a cube are called "chips".  There are two chips used in automatic
          registration, the "pattern" chip and the "search" chip, corresponding
          to the two sub-areas discussed above.   We will discuss each in more
          detail within the following sections, but for now we describe the
          basic elements of a chip.  That is, an NxM chip is defined to be an N
          sample by M line region of a cube.  Some key elements of a chip are
          as follows:

          <ol>
            <li>N and M are natural numbers (1, 2, 3, ...)</li>
            <li>Like cubes, chip coordinates are sample/line based and indexed from 1</li>
            <li>The center of the chip is (N-1)/2 + 1 and (M-1)/2 + 1.</li>
          </ol>

          Because a chip is a region of a cube, there must be a technique to
          "load" the chip.  The most common method for accomplishing this is to
          specify a cube coordinate (a sample and line) to be loaded as the
          center pixel of the chip.
        </p>

        <h3><a name="PatternChip">Pattern Chip</a></h3>
        <p>
          The pattern chip contains the data you want to match.  In the past we
          have called this the "truth" chip or "hold" chip.  Both of these
          terms can be confusing.  The term "truth" has different meanings in
          regards to match points and term "hold" is misleading as a pattern
          chip actually floats through the search chip. So we refrain from
          their use and stick with the term "pattern" chip.   The PVL for a
          pattern chip is:

          <pre style="padding-left:4em;">
            Object = AutoRegistration
              Group = PatternChip
                Samples = 5
                Lines   = 5
              End_Group
            End_Object
          </pre>
        </p>

        <h3><a name="SearchChip">Search Chip</a></h3>
        <p>
          The search chip is the area of an overlapping cube you believe the
          pattern will fall within.  That is, we will walk the pattern chip
          through the search chip looking for the best match.  The size of the
          search chip defines how far the pattern chip is allowed to deviate
          from a desired center search spot.  Consequently, the search chip
          must be larger than the pattern chip in order for the pattern chip to
          move through the search chip:  

          <pre style="padding-left:4em;">
            Object = AutoRegistration
              Group = PatternChip
                Samples = 5
                Lines   = 5
              End_Group

              Group = SearchChip
                Samples = 21
                Lines   = 21
              End_Group
            End_Object
          </pre>
        </p>

        <h3><a name="Restrictions">Restrictions</a></h3>
        <p>
          From the above discussion of pattern and search chips, an intuition
          should be developing about how changes to one chip will necessitate
          changes to the other.  Because the pattern chip and search chip are
          tightly coupled in this way, there are some restrictions on the
          relative dimensions of the two chips that must be put in place.
          Specifically:

          <ol>
            <li>
              <strong>N + M >= 3</strong>
              <br />
              where N and M are the dimensions of the pattern chip.  This
              ensures the pattern is not a single pixel.  However, in practice,
              small pattern chips often match too many areas in a search chip.
            </li>
            <li>
              <strong>
                N<sub>search</sub> >= N<sub>pattern</sub>+2
              </strong>
              and
              <strong>
                M<sub>search</sub> >= M<sub>pattern</sub>+2
              </strong>
              <br />
              where N and M are again the dimensions of their respective chips.
              This ensures that the pattern chip spans at least a 3x3 window in
              the search chip.  This is a subtle but important requirement for
              surface fitting in order to compute sub-pixel accuracy (which
              will be discussed later in this document).
            </li>
          </ol>
        </p>

        <!-- Match Algorithms -->
        <h2><a name="MatchAlgorithms">Match Algorithms</a></h2>
        <p>
          Rarely in practice will the pixels in a search chip have a one-to-one
          correspondance with some sub-area of the search chip.  Consequently,
          we introduce match algorithms designed to correlate two chips and
          find the "best" match within the search area.
        </p>
        <p>
          An objective of the Isis 3 automatic registration design is to allow
          for a variety of match algorithms.  For example, an algorithm could
          be developed that works best for matching MGS/MOC wide angle and
          Odyssey Themis IR cameras.  For this objective to be met we will
          utilize applications which allow automatic registration plugins.
          This concept is identical to that of applications which utilize
          camera and/or map projection plugins such as cam2map, map2map, etc. 
        </p>
        <p>
          The plugin match algorithm will receive the pattern chip and a
          sub-region of the search chip.  This sub-region will have the same
          dimensions as the pattern chip to allow for a pixel-by-pixel
          comparison of the chips.  The algorithm is expected to return a
          single value that represents the "goodness of fit" (GOF) between the
          two chips.   The definition of the GOF is algorithm dependent.  For
          clarity, we present two types of match algorithms in this document
          with the understanding that more algorithms may be developed in the
          future.
        </p>

        <h3><a name="MaximumCorrelation">Maximum Correlation</a></h3>
        <p>
          This match algorithm computes the correlation coefficient, R, between
          the pattern chip and the sub-region of the search chip as follows:

          <pre style="padding-left:4em;">
            R = Covariance(pattern, subregon) / [Variance(pattern) * Variance(subregion)]

            where -1.0 &lt;= R &lt;= 1.0

            GOF = |R|
          </pre>

          In this algorithm, the goodness of fit will range from no correlation
          (zero) to perfect correlation (one).  Example PVL for this algorithm
          would as follows:

          <pre style="padding-left:4em;">
            Object = AutoRegistration
              Group = PatternChip
                Samples = 5
                Lines   = 5
              End_Group

              Group = SearchChip
                Samples = 21
                Lines   = 21
              End_Group

              Group = Algorithm 
                Name    = MaximumCorrelation
              End_Group
            End_Object
          </pre>
        </p>

        <h3><a name="MinimumDifference">Minimum Difference</a></h3>
        <p>
          This match algorithm defines goodness-of-fit as the average absolute
          difference per pixel between the pattern chip and the search
          sub-region.  Specifically, it sums the pixel differences within the
          pattern chip and search sub-region and divides by the total pixel
          count to get an average.  In equation form:

          <pre style="padding-left:4em;">
            GOF =  <span style="font-size:2.0em;">&#931;</span>|pattern(i,j) - subregion(i,j)| / count
          </pre>

          A GOF value of zero indicates a perfect match, while larger values
          indicate a less likely match.  Obviously, negative values could never
          occur.
        </p>
        <p>
          To have your automatic registration use this Minimum Difference
          algorithm, specify the following in the "Algorithm" group of your PVL
          definition file:

          <pre style="padding-left:4em;">
            Object = AutoRegistration
              Group = PatternChip
                Samples = 5
                Lines   = 5
              End_Group

              Group = SearchChip
                Samples = 21
                Lines   = 21
              End_Group

              Group = Algorithm 
                Name    = MinimumDifference
              End_Group
            End_Object
          </pre>
        </p>

        <h3><a name="Gruen">Gruen</a></h3>
        <p>
          This algorithm provides adaptive image (chip) registration using an
          Affine transform to iteratively adjust the search chip at each
          iteration.  Each iteration solves for new adjustments to the Affine
          transform until the 6 affine parameters fall below the tolerances as
          specified in AffineThreshold1 and AffineThreshold2.
        </p>
        <p>
          This algorithm minimizes the 6 specifiable Affine transform
          components of a 3x3 matrix.  The three Affine components for X
          (sample) and Y (line) are scale, shear, and translation.  Gruen
          provides control over the maximum values these three components
          should attain in order for the registration to converge to a
          successful match.  These limits are specified by
          <b>AffineScaleTolerance</b>, <b>AffineShearTolerance</b> and
          <b>AffineTranslationTolerance</b>.  <b>AffineShearTolerance</b> is
          optional and if not specified, it defaults to the value of
          <b>AffineScaleTolerance</b>.  These tolerances specify the maximum
          amount of translation pixels can be shifted between one Gruen
          iteration and another.  For example:

          <pre style="padding-left:4em;">
            AffineTranslationTolerance = 0.2
          </pre>

          ...means that a subsearch chip cannot move in sample or line
          direction more than 0.2 pixels in order to satisfy convergence.
          <b>AffineScaleTolerance</b> constrains the sample and line scale
          elements of the Affine transformation.  And
          <b>AffineShearTolerance</b> constrains the sample and line shear
          elements of the Affine transformation.  The scale and shear
          parameters are scaled by size of the Chip.  The sample scale and
          shear Affine components maximum limit is computed as:

          <pre style="padding-left:4em;">
            SampleMaximum = AffineScaleTolerance / ((#Samples - 1) / 2)
            SampleMaximum = AffineShearTolerance / ((#Samples - 1) / 2)
          </pre>

          Likewise, the line scale and shear maximums are computed using
          <b>#Lines</b> in the preceding equation.
        </p>
        <p>
          Example PVL for this algorithm would as follows:

          <pre style="padding-left:4em;">
            Object = AutoRegistration
              Group = PatternChip
                Samples = 5
                Lines   = 5
              End_Group

              Group = SearchChip
                Samples = 21
                Lines   = 21
              End_Group

              Group = Algorithm 
                Name                       = Gruen
                MaximumIterations          = 30
                AffineTranslationTolerance = 0.2
                AffineScaleTolerance       = 0.7
                AffineShearTolerance       = 0.7
                AffineTolerance            = 5.0
                SpiceTolerance             = 7.0
                RadioShiftTolerance        = 256.0
                RadioGainMinTolerance      = -0.75
                RadioGainMaxTolerance      = 3.0
                FitChipScale               = 0.1
                DefaultRadioGain           = 0.0
                DefaultRadioShift          = 0.0
              End_Group
            End_Object
          </pre>
        </p>

        <h3><a name="Tolerance">Tolerance</a></h3>
        <p>
          In both algorithms we will want to define a tolerance for goodness of
          fit.   The tolerance test must be made by the plugin as the direction
          of the test is dependent on the algorithm.  In our two examples
          MinimumDifference would use a test for "less than" Tolerance while the
          MaximumCorrelation would use "greater than" Tolerance.  This is
          represented in PVL in the following fashion:

          <pre style="padding-left:4em;">
            Object = AutoRegistration
              Group = PatternChip
                Samples = 5
                Lines   = 5
              End_Group

              Group = SearchChip
                Samples = 21
                Lines   = 21
              End_Group

              Group = Algorithm 
                Name      = MaximumCorrelation
                Tolerance = 0.7
              End_Group
            End_Object 
          </pre>

          In fact, the plugin will have significant control such that one, two,
          or more tolerances or test conditions must be satisfied to accept the
          match.  For example:

          <pre style="padding-left:4em;">
            Group = Algorithm 
              Name      = SuperSpecialRegistration
              Tolerance = 0.7
              ChiSquare = 2.5
              R         = 0.6
              T         = 95.0
            End_Group
          </pre>
        </p>

        <!-- Creating a Fit Chip -->
        <h2><a name="CreatingFitChip">Creating a Fit Chip</a></h2>
        <p>
          We define a third chip, the fit chip, which represents the goodness of
          fit at each equivalent position in the search chip.  That is, we can
          think of the pattern chip walking through the search chip and at each
          position extract a sub-region to be used for computing a fit
          value. After walking and computing at each position we have a chip
          filled with goodness of fit values that are in 1-1 correspondence with
          pixels in the search chip.  An example of the pattern chip weaving its
          way through the search chip is given:
        </p>
        <img src="assets/exampleWalk.jpg" alt="Example Walk" />
        <p>
          How the pattern chip walks the search chip can vary; currently we
          define one method: a dense walk. 
        </p>

        <h3><a name="DenseWalk">Dense Walk</a></h3>
        <p>
          In the obvious case, we walk every possible position in the search
          chip by starting in the upper-left corner and moving over by one
          sample.  When we come to the right edge we will move down one line and
          reset to the left edge.  However, we do not test where the pattern
          would lie outside the search chip.  For example:
        </p>
        <img src="assets/denseWalk.jpg" alt="Dense Walk" />
        <p>
          In other words, we only test the pattern if it is fully inside of the
          search chip.  This will be true for all walking scenarios.  Therefore,
          if we have 3x3 pattern chip and a 7x7 search chip, we compute fits for
          25 of the 49 pixels in the search chip.
        </p>

        <!-- Sub-Pixel Accuracy -->
        <h2><a name="SubPixelAccuracy">Sub-Pixel Accuracy</a></h2>
        <p>
          Upon walking the pattern chip through the search chip we will have
          created the fit chip.  The highest (or lowest) goodness of fit value
          generally represents the position that best matched between the
          pattern and search area.  It is however only good to one pixel
          accuracy.
        </p>
        <p>
          In many cases, the actual registration may lie somewhere between two
          pixels. This is due to the fact that we are using a set of finite data
          to estimate something that is in fact continuous.
        </p>

        <h3><a name="SurfaceModeling">Surface Modeling</a></h3>
        <p>
          To get around the problem of a true best fit lying somewhere between
          two pixels, we can model a continuous mathematical surface based on
          the data in the fit chip. By using a
          <a href="http://en.wikipedia.org/wiki/Least-squares">
            least squares fit
          </a>
          to generate a 2nd degree 2-dimentional polynomial given an NxN
          window of points, we have a reasonable approximation under a given
          tolerance of the underlying structure. We can then estimate the true
          registration position of the chip on that surface.
        </p>
        <p>
          Optionally, the window size and tolerance may be supplied through PVL:

          <pre style="padding-left:4em;">
            Group = SurfaceModel
              DistanceTolerance = 2.5
              WindowSize        = 7
              EccentricityRatio = 50.0
              ResidualTolerance = 0.05
            End_Group
          </pre>

          The distance tolerance in pixels must be greater than 0 and is
          defaulted to 1.0. The window size must be an odd number greater than 2
          and is defaulted to 3.
        </p>
        <p>
          The eccentricity ratio and residual tolerance correspond to the
          optional eccentricity and average residual tests.  By default, neither
          test is performed during surface model construction.  However, if the
          SurfaceModel PVL group contains one of both of those keywords, it will
          enable the respective test(s) with the given tolerance(s).  
        </p>

        <h3><a name="FindingLocalMinMax">Finding a Local Minimum/Maximum</a></h3>
        <p>
          After a surface is modeled over the data, we can use a number of
          techniques to calculate the local extreme. For example, when using the
          MinimumDifference algorithm the registration occurs at the minimal
          value on the surface. The result should fall within one pixel of the
          best calculated fit.
        </p>
        <p>
          It is important to note that while the surface modeling option is on
          by default it is possible to turn it off by using the SubpixelAccuracy
          keyword. Example:

          <pre style="padding-left:4em;">
            Group = Algorithm 
              Name             = MaximumCorrelation
              Tolerance        = 0.7
              SubpixelAccuracy = False
            End_Group
          </pre>

          In this case, the whole pixel with the best fit is returned.
        </p>
        <p>
          Also, if an ideal goodness of fit is found (e.g. 0.0 for
          MinimumDifference or 1.0 for MaximumCorrelation), we have a perfect
          fit and, thus, know it is in the best position. In this case, the
          sub-pixel accuracy phase is omitted.
        </p>

        <h3><a name="DistanceTolerance">Distance Tolerance</a></h3>
        <p>
          The result of a sub-pixel accuracy computation is likely to move the
          result away from its original whole-pixel fit.  However, sometimes
          the move could be so drastic that it calls into question the validity
          of the match.  This tolerance value thus specifies the max number of
          pixels (with sub-pixel granularity) the sub-pixel accuracy
          computation can move the best fit before the registration is rejected
          entirely.  
        </p>
        <p>
          For example:

          <pre style="padding-left:4em;">
            Group = SurfaceModel
              DistanceTolerance = 3.5
            End_Group
          </pre>

          Here a registration will be rejected if the new position is more than
          3.5 pixels away from the original whole-pixel result.
        </p>

        <h3><a name="WindowSize">Window Size</a></h3>
        <p>
          When refining a whole-pixel match to sub-pixel accuracy, it's
          important to consider how much area around that best whole-pixel fit
          to sample for constructing a surface model.  The WindowSize keyword
          defines the size of the window, centered on the best whole-pixel
          match, that will be used for modelling the surface.  Values for
          WindowSize specify the N of an NxN chip, and must be odd numbers
          greater than or equal to 3.  By default, this window size is 5x5
          pixels, but can be specified in the SurfaceModel group as follows:

          <pre style="padding-left:4em;">
            Group = SurfaceModel
              WindowSize = 3
            End_Group
          </pre>

          Here we define our window to be 3x3 pixels around the best
          whole-pixel match, and the resulting surface will be modelled with
          the data in this chip.
        </p>

        <h3><a name="EccentricityRatio">Eccentricity Ratio</a></h3>
        <p>
          After the least squares fit is performed to model a surface, the
          ideal result is a circular formation of goodness-of-fit values
          improving towards the center of the surface.  The less circular, or
          more "eccentric", the formation of goodness-of-fit values, the less
          likely the modelling result is accurate.
        </p>
        <p>
          In an attempt to let the user define what constitutes a tolerable
          amount of eccentricity in their surface models, we introduce the
          notion of an "Eccentricity Ratio".  The name itself might be a bit
          misleading, as the value specified is not an actual ratio, nor is it
          compared directly to the eccentricity of the surface model.  Whereas
          the 
          <a href="http://mathworld.wolfram.com/Ellipse.html">
            mathematical definition of eccentricity
          </a>
          is a number between 0 and 1 -- those bounds representing a perfect
          circle and a parabola, respectively -- here we think of eccentricity
          itself as a ratio between the semi-major and semi-minor axes of an
          ellipse.  The value specified by the EccentricityRatio keyword then
          represents the user's tolerance for this ratio.  In other words, the
          EccentricityRatio keyword tells us how much bigger than the
          semi-minor axis the semi-major axis can be before we reject the
          result.
        </p>
        <p>
          For example, consider the following PVL:

          <pre style="padding-left:4em;">
            Group = SurfaceModel
              EccentricityRatio = 5.0
            End_Group
          </pre>

          In this instance, if the length of the semi-major axis of the
          computed surface model is greater than 5 times the length of the
          semi-minor axis, then the surface model will be thrown out and the
          registration will fail for that point.
        </p>
        <p>
          Sometimes the eccentricity can not be computed for a given surface
          model because the math simply doesn't work out (negative numbers
          appear in square root calculations).  In this case the eccentricity
          (in mathematical terms) is assumed to be 0, or perfectly circular.
        </p>
        <p>
          If the user does not wish to perform the eccentricity test on their
          surface models, the keyword can be optionally left out of the
          definition file and the test will be completely skipped.
        </p>

        <h3><a name="ResidualTolerance">Residual Tolerance</a></h3>
        <p>
          The least squares fit performed to construct the surface model takes
          discrete data from the whole-pixels around the best-fit (as defined
          by WindowSize).  When this discrete data is fit with a continuous
          function, there is likely going to be some amount of error between
          the original value for some pixel and its interpolated value in the
          least squares solution.  The ResidualTolerance keyword thus allows
          the user to specify the maximum average residual, or
          <a href="http://en.wikipedia.org/wiki/Mean_absolute_error">
            mean absolute error
          </a>,
          for all pixels in the surface model area, that will be tolerated
          before the sub-pixel accuracy computation is rejected and the
          registration fails for that point.
        </p>
        <p>
          An example of using this keyword in PVL:

          <pre style="padding-left:4em;">
            Group = SurfaceModel
              ResidualTolerance = 0.1
            End_Group
          </pre>

          With the ResidualTolerance set here to 0.1, if the average residual
          of the surface model is greater than 0.1, the sub-pixel accuracy
          computation will be rejected and the registration will fail for that
          point.
        </p>

        <!-- Advanced Features -->
        <h2><a name="AdvancedFeatures">Advanced Features</a></h2>
        <p>
          This section covers advanced features of automatic
          registration.  While these features are not necessary in order to
          accomplish the registration, they can be used to significantly improve
          the chance of success and/or the accuracy of the match.
        </p>

        <h3><a name="RestrictingPixelRanges">Restricting Pixel Ranges</a></h3>
        <p>
          Pixels may be excluded from the match algorithm if they fall outside
          of a specified range.  This range is independent for both the pattern
          and search chip.  It is handled via the PVL as follows:

          <pre style="padding-left:4em;">
            Object = AutoRegistration
              Group = PatternChip
                Samples      = 5
                Lines        = 5
                ValidMinimum = 0.1
                ValidMaximum = 0.4
              End_Group

              Group = SearchChip
                Samples      = 21
                Lines        = 21
                ValidMinimum = 2.5
                ValidMaximum = 10.5
              End_Group

              ...
            End_Object
          </pre>

          If values are not given in the PVL then all pixels are considered
          valid (with the exception of special pixels).
        </p>

        <h3><a name="ValidPixelCount">Valid Pixel Count</a></h3>
        <p>
          Prior to the match algorithm being invoked during the walk process, a
          simple test is performed to ensure there are enough pixels to work
          with.  Pixels are deemed valid if they are in the minimum/maximum
          range and/or they are not special pixels.  The pattern chip is only
          checked once.  If it does not contain enough valid pixels the match is
          deemed to fail.  As the walk through occurs, the sub-region is
          extracted from the search chip. If this sub-region does not have
          enough valid pixels a match will be deemed to fail at that search
          location.  In the following PVL example we have a 5x5 chip with 25
          pixels of which 80% or more must be valid:

          <pre style="padding-left:4em;">
            Group = PatternChip
              Samples      = 5
              Lines        = 5
              ValidMinimum = 0.1
              ValidMaximum = 0.4
              ValidPercent = 80
            End_Group
          </pre>

          We only need to specify the percent for the pattern chip as the
          sub-region chip of the search area will use the same value. 
        </p>

        <h3><a name="ReductionFactor">Reduction Factor</a></h3>
        <p>
          The automatic registration process can often be a time-consuming one,
          especially when needing to consider a large search area to walk
          through.  In order to help speed up this portion of the process, we
          introduce the notion of a "Reduction Factor".
        </p>
        <p>
          If a reduction factor greater than 1 is specified by the user, then
          before attempting to walk the pattern chip through the search chip
          looking for a match, the algorithm will first perform a "reduced
          match".  In other words, new pattern and search chips will be created
          with dimensions equal to the original chip dimensions divided by the
          reduction factor, and a match will be performed on them first to help
          refine the general match to a smaller search area.  For example, a
          common reduction factor is 1.5, and can be specified in the
          definition file as follows:

          <pre style="padding-left:4em;">
            Object = AutoRegistration
              Group = Algorithm
                ReductionFactor = 1.5
              End_Group

              Group = PatternChip
                Samples      = 5
                Lines        = 5
              End_Group

              Group = SearchChip
                Samples      = 21
                Lines        = 21
              End_Group
            End_Object
          </pre>

          In the above example, a new pattern chip would be constructed with
          dimensions of 3 samples by 3 lines (i.e., 5 / 1.5 rounded down).  The
          new search chip, likewise, would be 14 samples by 14 lines (i.e., 21
          / 1.5).
        </p>
        <p>
          Of course, by reducing the chips we lose an amount of detail directly
          proportionate to the magnitude of the reduction factor.  Increasing
          the reduction factor will speed up computation, but also decrease the
          reliability of the result.  A pixel in a reduced chip is simply
          computed by averaging surrounding pixels in the original chip.
        </p>
        <p>
          After the match has been performed on the reduced chips, instead of
          simply accepting the result, the algorithm will continue on to
          matching the original chips, but decrease the search area to a
          smaller area surrounding the "best" sample and line derived from the
          reduced match, effectively cropping the search chip (not scaling it,
          as in the reduced match) to some general area suspected to contain
          the exact match.  Increasing the reduction factor will increase the
          size of the resulting search area.
        </p>
        <p>
          After finding the reduced match, the new search window is defined by
          expanding outwards from the best pixel (remapped from the reduced
          chips to the original chips) by:

          <pre style="padding-left:4em;">
            ReductionFactor + WindowSize + 1
          </pre>

          ...in all four directions.  The WindowSize can be specified by the
          user in the definition file's SurfaceModel group.  To help understand
          why the reduction factor is used in this manner, consider the
          following example:

          <pre style="padding-left:4em;">
            Object = AutoRegistration
              Group = Algorithm
                ReductionFactor = 10
              End_Group

              Group = PatternChip
                Samples         = 700
                Lines           = 700
              End_Group

              Group = SearchChip
                Samples         = 1000
                Lines           = 1000
              End_Group

              Group = SurfaceModel
                WindowSize      = 3
              End_Group
            End_Object
          </pre>

          Using a reduction factor of 10: the search chip becomes 100x100, the
          pattern 70x70, and only 900 different comparison are made.  However,
          the best pixel match is only accurate to about 10 pixels because of
          the reduction.  So we repeat the matching process in a window around
          the best pixel.  The windows size is 10 in either direction plus the
          number of pixels needed for sub-pixel accuracy computations
          (WindowSize is usually 3).  In the our case the matching would be
          done on a 2 * (10 + 3 + 1) or 28x28 window, or 784 additional
          comparisons.  Therefore the total comparisons to get a match is 900 +
          784 = 1684 and is significantly less than the 90000 comparisons done
          without the reduction factor.
        </p>
        <p>
          Adaptive algorithms will make additional use the "best" sample and
          line dervied from the reduced match when setting up affine
          transformations.
        </p>

        <h3><a name="GeoWarping">Geometric Warping of Pattern Cubes</a></h3>
        <p>
          The pattern cube can be forced to match the geometry of the search
          cube by using map projections and/or camera models.  Additionally,
          rotations can be applied to the pattern cube.  The warping is
          application-dependent and therefore is under the control of the
          programmer.  That is, there is no PVL mechanism for warp
          selection/deselection.
        </p>
        <p>
          However, when interpolating during the warp process, the user can
          choose, via the definition file, which interpolation algorithm to
          use.  Available interpolation algorithms include 
          <a href="http://en.wikipedia.org/wiki/Nearest-neighbor_interpolation">
            Nearest Neighbor
          </a>,
          <a href="http://en.wikipedia.org/wiki/Bilinear_interpolation">
            Bilinear
          </a>,
          and
          <a href="http://en.wikipedia.org/wiki/Bicubic_interpolation#Bicubic_convolution_algorithm">
            Cube Convolution
          </a>.
          As an example of how to specify which algorithm to use:

          <pre style="padding-left:4em;">
            Group = Algorithm
              ChipInterpolator = NearestNeighborType
            End_Group
          </pre>

          The above example would warp the geometry of the pattern cube using
          the Nearest Neighbor algorithm.  For a complete list of all
          possible values for this keyword, see the 
          <a href="#DeffileKeywords">Definition File Keywords</a>
          appendix below.
        </p>

        <h3><a name="ZScoreTest">Z-Score Test</a></h3>
        <p>
          To guarantee an accurate match, we first need to check if the pattern
          chip has enough variation to perform the algorithm on. This is done by
          calculating the z-score of both the minimum and maximum values of the
          chip. The z-score measures the number of standard deviations the value
          is away from the mean. If the z-score for either value is greater than
          the specified minimum value, then it is an acceptable pattern
          chip. For example:

          <pre style="padding-left:4em;">
            Group = PatternChip 
              MinimumZScore = 1.5
            End_Group
          </pre>

          In this case, the chip's extreme values must be more than 1.5 standard
          deviations away from the mean. If the MinimumZScore keyword is not
          included, the default value of 1 standard deviation is used.
        </p>

        <h3><a name="GradientFilters">Gradient Filters</a></h3>
        <p>
          To increase the chances of successful registration, a gradient filter
          can be applied to both the search and pattern chips before attempting
          to perform a match. A gradient filter basically calculates the
          magnitude and direction of the largest possible increase from light to
          dark. In simple terms, a gradient filter highlights the edges in an
          image. Thus, the use of a gradient filter on the search and pattern
          chips may increase the chances of finding a match when the pattern
          chip contains distinctive features whose edges need to be emphasized.
        </p>
        <p>
          Currently,
          <a href="http://en.wikipedia.org/wiki/Sobel_operator">
            Sobel
          </a>
          and
          <a href="http://en.wikipedia.org/wiki/Roberts_Cross">
            Roberts
          </a> 
          gradient filters are supported. The Sobel gradient filter looks at
          the eight surrounding pixels for a given point, while the Roberts
          gradient filter computes the sum of the squares of the differences
          between diagonally adjacent pixels. A Sobel gradient filter can be
          specified like so:

          <pre style="padding-left:4em;">
            Group = Algorithm
              Gradient = Sobel
            End_Group
          </pre>
        </p>

        <!-- Appendices -->
        <h2><a name="Appendices">Appendices</a></h2>
        <p>
          Here you'll find a collection of quick references to help improve
          your results when performing automatic registration.
        </p>

        <h3><a name="DeffileKeywords">Definition File Keywords</a></h3>
        <p>
          The following table provides an exhaustive listing of every
          <strong>keyword</strong> that can be provided in an automatic
          registration definition file.  The keywords are organized by what
          <strong>groups</strong> they can appear in after what
          <strong>algorithms</strong> they can be used with.  If a keyword can
          be used with every algorithm, then its value for this cell is "All".
          The <strong>type</strong> column specifies what kind of value is
          expected (an integer, real number, boolean, or a string).  The
          <strong>values</strong> column provides either the set of valid
          values (in the case of strings) or a numerical range, with a paren
          "(" denoting an exclusive value and a bracket "[" denoting an
          inclusive value.  The <strong>default</strong> column provides the
          value that will be taken when the keyword is not provided.  If the
          value for a particular cell is <span style="color:red;">red</span>,
          then instead of the corresponding keyword defaulting to some value in
          the registration process, the stated action will be performed.  In
          the case of an <span style="color:red;">Exception</span>, unless the
          specific application being used handles the missing value, the
          registration will fail.
        </p>

        <table class="tableFormattedInformation" align="center">
          <!-- Headers -->
          <tr>
            <th>Keyword</th>
            <th>Groups</th>
            <th>Algorithms</th>
            <th>Type</th>
            <th>Values</th>
            <th>Default</th>
          </tr>

          <!-- Algorithm -->
          <tr>
            <td><a href="#MatchAlgorithms"><strong>Name</strong></a></td>
            <td>Algorithm</td>
            <td>All</td>
            <td>String</td>
            <td>{MaximumCorrelation, MinimumDifference, Gruen, AdaptiveGruen}</td>
            <td><span style="color:red;">Exception</span></td>
          </tr>
          <tr>
            <td><a href="#Tolerance"><strong>Tolerance</strong></a></td>
            <td>Algorithm</td>
            <td>All</td>
            <td>Real</td>
            <td>[0.0, infinity)</td>
            <td><span style="color:red;">Exception</span></td>
          </tr>
          <tr>
            <td><a href="#GeoWarping"><strong>ChipInterpolator</strong></a></td>
            <td>Algorithm</td>
            <td>All</td>
            <td>String</td>
            <td>{NearestNeighborType, BiLinearType, CubicConvolutionType}</td>
            <td>CubicConvolutionType</td>
          </tr>
          <tr>
            <td><a href="#ReductionFactor"><strong>ReductionFactor</strong></a></td>
            <td>Algorithm</td>
            <td>All</td>
            <td>Integer</td>
            <td>[1, infinity)</td>
            <td>1</td>
          </tr>
          <tr>
            <td><a href="#SubPixelAccuracy"><strong>SubPixelAccuracy</strong></a></td>
            <td>Algorithm</td>
            <td>All</td>
            <td>Boolean</td>
            <td>{True, False}</td>
            <td>True</td>
          </tr>
          <tr>
            <td><a href="#GradientFilters"><strong>Gradient</strong></a></td>
            <td>Algorithm</td>
            <td>All</td>
            <td>String</td>
            <td>{None, Roberts, Sobel}</td>
            <td>None</td>
          </tr>

          <!-- Pattern Chip -->
          <tr>
            <td><a href="#Chips"><strong>Samples</strong></a></td>
            <td>PatternChip, SearchChip</td>
            <td>All</td>
            <td>Integer</td>
            <td>[1, infinity)</td>
            <td><span style="color:red;">Exception</span></td>
          </tr>
          <tr>
            <td><a href="#Chips"><strong>Lines</strong></a></td>
            <td>PatternChip, SearchChip</td>
            <td>All</td>
            <td>Integer</td>
            <td>[1, infinity)</td>
            <td><span style="color:red;">Exception</span></td>
          </tr>
          <tr>
            <td><a href="#RestrictingPixelRanges"><strong>ValidMinimum</strong></a></td>
            <td>PatternChip, SearchChip</td>
            <td>All</td>
            <td>Real</td>
            <td>(-infinity, infinity)</td>
            <td>Isis::ValidMinimum</td>
          </tr>
          <tr>
            <td><a href="#RestrictingPixelRanges"><strong>ValidMaximum</strong></a></td>
            <td>PatternChip, SearchChip</td>
            <td>All</td>
            <td>Real</td>
            <td>(-infinity, infinity)</td>
            <td>Isis::ValidMaximum</td>
          </tr>
          <tr>
            <td><a href="#ZScoreTest"><strong>MinimumZScore</strong></a></td>
            <td>PatternChip</td>
            <td>All</td>
            <td>Real</td>
            <td>(0.0, infinity)</td>
            <td>1.0</td>
          </tr>
          <tr>
            <td><a href="#ValidPixelCount"><strong>ValidPercent</strong></a></td>
            <td>PatternChip</td>
            <td>All</td>
            <td>Real</td>
            <td>(0.0, 100.0]</td>
            <td>50.0</td>
          </tr>

          <!-- Search Chip -->
          <tr>
            <td><a href="#ValidPixelCount"><strong>SubchipValidPercent</strong></a></td>
            <td>SearchChip</td>
            <td>All</td>
            <td>Real</td>
            <td>(0.0, 100.0]</td>
            <td>50.0</td>
          </tr>

          <!-- Surface Model -->
          <tr>
            <td><a href="#DistanceTolerance"><strong>DistanceTolerance</strong></a></td>
            <td>SurfaceModel</td>
            <td>All</td>
            <td>Real</td>
            <td>(0.0, infinity)</td>
            <td>1.5</td>
          </tr>
          <tr>
            <td><a href="#WindowSize"><strong>WindowSize</strong></a></td>
            <td>SurfaceModel</td>
            <td>All</td>
            <td>Integer</td>
            <td>[3, infinity) odd</td>
            <td>5</td>
          </tr>
          <tr>
            <td><a href="#EccentricityRatio"><strong>EccentricityRatio</strong></a></td>
            <td>SurfaceModel</td>
            <td>All</td>
            <td>Real</td>
            <td>[1.0, infinity]</td>
            <td><span style="color:red;">No Eccentricity Test</span></td>
          </tr>
          <tr>
            <td><a href="#ResidualTolerance"><strong>ResidualTolerance</strong></a></td>
            <td>SurfaceModel</td>
            <td>All</td>
            <td>Real</td>
            <td>[0.0, infinity]</td>
            <td><span style="color:red;">No Residual Test</span></td>
          </tr>

          <!-- Gruen -->
          <tr>
            <td><a href="#Gruen"><strong>MaximumIterations</strong></a></td>
            <td>Algorithm</td>
            <td>Gruen</td>
            <td>Integer</td>
            <td>(-infinity, infinity)</td>
            <td>25</td>
          </tr>
          <tr>
            <td><a href="#Gruen"><strong>AffineTranslationTolerance</strong></a></td>
            <td>Algorithm</td>
            <td>Gruen</td>
            <td>Real</td>
            <td>(-infinity, infinity)</td>
            <td>0.1</td>
          </tr>
          <tr>
            <td><a href="#Gruen"><strong>AffineScaleTolerance</strong></a></td>
            <td>Algorithm</td>
            <td>Gruen</td>
            <td>Real</td>
            <td>(-infinity, infinity)</td>
            <td>0.5</td>
          </tr>
          <tr>
            <td><a href="#Gruen"><strong>AffineShearTolerance</strong></a></td>
            <td>Algorithm</td>
            <td>Gruen</td>
            <td>Real</td>
            <td>(-infinity, infinity)</td>
            <td>AffineScaleTolerance</td>
          </tr>
          <tr>
            <td><a href="#Gruen"><strong>AffineTolerance</strong></a></td>
            <td>Algorithm</td>
            <td>Gruen</td>
            <td>Real</td>
            <td>(-infinity, infinity)</td>
            <td>DBL_MAX</td>
          </tr>
          <tr>
            <td><a href="#Gruen"><strong>SpiceTolerance</strong></a></td>
            <td>Algorithm</td>
            <td>Gruen</td>
            <td>Real</td>
            <td>(-infinity, infinity)</td>
            <td>DBL_MAX</td>
          </tr>
          <tr>
            <td><a href="#Gruen"><strong>RadioShiftTolerance</strong></a></td>
            <td>Algorithm</td>
            <td>Gruen</td>
            <td>Real</td>
            <td>(-infinity, infinity)</td>
            <td>DBL_MAX</td>
          </tr>
          <tr>
            <td><a href="#Gruen"><strong>RadioGainMinTolerance</strong></a></td>
            <td>Algorithm</td>
            <td>Gruen</td>
            <td>Real</td>
            <td>(-infinity, infinity)</td>
            <td>-DBL_MAX</td>
          </tr>
          <tr>
            <td><a href="#Gruen"><strong>RadioGainMaxTolerance</strong></a></td>
            <td>Algorithm</td>
            <td>Gruen</td>
            <td>Real</td>
            <td>(-infinity, infinity)</td>
            <td>DBL_MAX</td>
          </tr>
          <tr>
            <td><a href="#Gruen"><strong>FitChipScale</strong></a></td>
            <td>Algorithm</td>
            <td>Gruen</td>
            <td>Real</td>
            <td>(-infinity, infinity)</td>
            <td>0.1</td>
          </tr>
          <tr>
            <td><a href="#Gruen"><strong>DefaultRadioGain</strong></a></td>
            <td>Algorithm</td>
            <td>Gruen</td>
            <td>Real</td>
            <td>(-infinity, infinity)</td>
            <td>0.0</td>
          </tr>
          <tr>
            <td><a href="#Gruen"><strong>DefaultRadioShift</strong></a></td>
            <td>Algorithm</td>
            <td>Gruen</td>
            <td>Real</td>
            <td>(-infinity, infinity)</td>
            <td>0.0</td>
          </tr>
        </table>

      </body>

      <type>HTML</type>
      <source>
        <filename>PatternMatch.html</filename>
      </source>
    </file>
  </files>

  <category>
    <categoryItem>guide</categoryItem>
  </category>

  <audience>
    <target>advanced</target>
  </audience>

  <bibliography>
    <title>Pattern Matching</title>
    <brief>
      A discussion of pattern matching techniques used in ISIS, designed to help
      users construct automatic registration templates.
    </brief>
    <description>
      This article describes the pattern matching techniques used for automatic
      registration in ISIS.  The information is designed to give users an idea
      of how they can alter their automatic registration templates to improve
      their results from applications such as "pointreg" and "coreg".  This
      should also give programmers a better understanding of how AutoReg works.
    </description>
    <author>Travis Addair</author>
    <date>2011-02-23</date>
  </bibliography>

  <history>
    <change name="Travis Addair" date="2011-02-23">
      Original version
    </change>
    <change name="Jai Rideout" date="2011-03-10">
      Added gradient filter section
    </change>
  </history>
</documentation>
